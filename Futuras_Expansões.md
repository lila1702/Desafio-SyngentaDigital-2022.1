# Expans√£o do Projeto üìÇ

Como mencionado no [README](README.md), o projeto no estado atual em que se encontra foi feito especificamente
para lidar apenas com os tr√™s hot√©is propostos pelo desafio.

Uma expans√£o iria incluir as seguintes funcionalidades:

- Adicionar um n√∫mero indefinido de hot√©is;
- Marcar a data inicial da viagem e a data final da viagem;
- Comparar os pre√ßos totais da estadia entre todos os hot√©is;
- Em casos de empate no pre√ßo, comparar todas as classifica√ß√µes entre si.

## Como eu faria isso?

Primeiramente, seria recomendado a utiliza√ß√£o de alguma forma de banco de dados para receber
os hot√©is que o programa poderia utilizar de refer√™ncia. Assim, n√£o seria necess√°rio o uso de classes para
guardar as informa√ß√µes de cada hotel.

Para este exemplo, o banco de dados √© uma matriz bidimensional, que atrav√©s de la√ßo(s) *for*, poderia ir
comparando cada pre√ßo, de acordo com o tipo de cliente e com o dia da semana.

| Nome Hotel   | Classifica√ß√£o | Pre√ßo Regular - Dia √ötil | Pre√ßo Regular - Fim de Semana | Pre√ßo Reward - Dia √ötil | Pre√ßo Reward - Fim de Semana |
|--------------|---------------|--------------------------|-------------------------------|-------------------------|------------------------------|
| Lakewood     |       3       |         110              |              90               |             80          |               80             |
| Bridgewood   |       4       |         160              |              60               |            110          |               50             |
| Ridgewood    |       5       |         220              |             150               |            100          |               40             |
|**Silverlake**|     **3**     |       **155**            |           **100**             |           **90**        |             **70**           |

```
tipo_cliente = ("Regular" ou "Reward")
datas = [data1, data2, ..., dataN)
cheapest_hotel = ["nome", 0, 100000000] # Nome, classifica√ß√£o e pre√ßo provis√≥rios

for linha in range(len(hoteis)):
  # Pula a linha que indica o que √© o que na tabela
  if(linha == 0):
    continue
  
  for coluna in range(len(hoteis)):
    classificacao = hoteis[linha][1]
    
    if(coluna == 0):
      continue
      
    if(tipo_cliente == "Regular" and coluna == 2 or tipo_cliente == "Regular" and coluna == 3):
      valor = calcular_preco_estadia(datas, hoteis[linha][2], hoteis[linha][3])
      
      if (valor < cheapest_hotel[2]):
        cheapest_hotel = [hoteis[linha][0], hoteis[1], valor]
      elif (valor == cheapest_hotel[1]):
        cheapest_hotel = [hoteis[linha][0], hoteis[1], valor] if classificacao > cheapest_hotel[1] else cheapest_hotel
      else:
        cheapest_hotel = cheapest_hotel
    
    else:
      valor = calcular_preco_estadia(datas, hoteis[linha][5], hoteis[linha][5])
      
      if (valor < cheapest_hotel[2]):
        cheapest_hotel = [hoteis[linha][0], hoteis[1], valor]
      elif (valor == cheapest_hotel[1]):
        cheapest_hotel = [hoteis[linha][0], hoteis[1], valor] if classificacao > cheapest_hotel[1] else cheapest_hotel
      else:
        cheapest_hotel = cheapest_hotel
```

Tamb√©m criaria uma fun√ß√£o que calcularia o valor total da estadia, de acordo com a data inicial e final.

```
calcular_preco_estadia(datas, preco_dia_util, preco_fim_de_semana):
  total = 0
  for dia in datas:
    if(dia.isoweekday() <= 5):
      total += preco_dia_util
    else:
      total += preco_fim_de_semana
  
  return total
```

Por fim, seria necess√°rio algo para servir de interface que interage com o usu√°rio.
Seria necess√°rio um main.py com um loop, que recebe as datas de chegada e sa√≠da ao hotel, e op√ß√µes de quebra do loop, caso o usu√°rio deseje sair do programa.

Se fossemos continuar com o programa apenas com linhas de comando, ficaria algo como:
```
import datetime

while(True):
  print("Digite a data de chegada ao hotel:")
  data_chegada = input("dd/mm/aaaa: ")
  print("Digite a data de s√°ido do hotel:")
  data_saida = input("dd/mm/aaaa: ")
    
  try:
    if("/" in data_chegada or "/" in data_saida):
      data_chegada = data_chegada.replace("/", "")
      data_saida = data_saida.replace("/", "")
        
      data_chegada = datetime.datetime.strptime(data_chegada, "%d%m%Y")
      data_saida = datetime.datetime.strptime(data_saida, "%d%m%Y")
  except:
    print("Digite as datas novamente, no formato dd/mm/aaaa")
    continue
    
    print("Deseja continuar?")
    continuar = input("(S/N): ")
    continuar = continuar.upper()
    
    if(continuar == "N"):
  	  break
```

Caso fosse utilizar alguma interface gr√°fica, haveria adapta√ß√µes, mas o princ√≠pio seguiria o mesmo.
